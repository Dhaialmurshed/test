# -*- coding: utf-8 -*-
"""2_Violencepred_TEST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_gFWHzk8ThOLVUWGzVuqxPPu_Lsk5DUI
"""

import firebase_admin
# from firebase import firebase
from firebase_admin import credentials, storage
# from firebase_admin import firebase
from firebase_admin import firestore # database

import pyrebase # for the storage
import os
firebaseConfig={
    "apiKey": "AIzaSyAN6rb8AKV_qMYknz38SVBZPcp3DGYWzzs",
    "authDomain": "rasd-d3906.firebaseapp.com",
    "databaseURL": "https://rasd-d3906.firebaseio.com",
    "projectId": "rasd-d3906",
    "storageBucket": "rasd-d3906.appspot.com",
    "messagingSenderId": "631946154635",
    "appId": "1:631946154635:android:57200f3f24d236d430fa8e",
    'serviceAccount': 'rasd-d3906-firebase-adminsdk-1djor-9976e852c3.json'
    }


firebase = pyrebase.initialize_app(firebaseConfig) # for storage configure 
storage = firebase.storage() #storage
#upload file

# file1 = '/content/drive/MyDrive/GP2_DS/reverse testing/1_841_reverse.mp4'

# cloudfilename = 'TestPython/1_841_reverse.mp4'
# storage.child(cloudfilename).put(file1)
# # cloudfilename = 'TestPython/2.mp4'

# one url
# print(storage.child(cloudfilename).get_url(None))


#------------------Download files---------------

all_files = storage.list_files() # list all files in the storage

for file in all_files:
    print("File name: " + file.name +  " Link: " + storage.child(file.name).get_url(None))
    print(os.path.split(file.name)[1]) # file name (only the video name)
    print("filefile",file.name.split("/")[0]) # user id 
print("File name: " + file.name +  " Link: " + storage.child(file.name).get_url(None))

# from google.auth import credentials
cred = credentials.Certificate("rasd-d3906-firebase-adminsdk-1djor-9976e852c3.json")
firebase_admin.initialize_app(cred , {'storageBucket':'rasd-d3906.appspot.com'}) # run once ( database config )



# firebase = pyrebase.initialize_app(firebaseConfig)
# storage = firebase.storage()
db = firestore.client()

# from keras.models import load_model
from collections import deque
import matplotlib.pyplot as plt
import numpy as np
import argparse
import pickle
import cv2

#WORKING PROJECT
import numpy as np
import argparse
import pickle
import cv2
from google.colab.patches import cv2_imshow
import os
import time 
import tensorflow as tf
# from keras.models import load_model
from collections import deque

def print_results(video, filename, limit=None):
        trueCount = 0

        print("video.name",filename)
        print("video",video)

        #fig=plt.figure(figsize=(16, 30))
        # if not os.path.exists('output'):
        #     os.mkdir('output')

        print("Loading model ...")
        model = tf.lite.Interpreter(model_path='model.tflite')
#         model = load_model('model.tflite')
        Q = deque(maxlen=128)
        vs = cv2.VideoCapture(video)
        writer = None
        (W, H) = (None, None)
        count = 0     
        while True:
            # read the next frame from the file
            (grabbed, frame) = vs.read()

            # if the frame was not grabbed, then we have reached the end
            # of the stream
            if not grabbed:
                break
            
            # if the frame dimensions are empty, grab them
            if W is None or H is None:
                (H, W) = frame.shape[:2]

            # clone the output frame, then convert it from BGR to RGB
            # ordering, resize the frame to a fixed 128x128, and then
            # perform mean subtraction

            
            output = frame.copy()
           
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (128, 128)).astype("float32")
            frame = frame.reshape(128, 128, 3) / 255

            # make predictions on the frame and then update the predictions
            # queue
            preds = model.predict(np.expand_dims(frame, axis=0))[0]
            print("preds",preds)
            Q.append(preds)

            # perform prediction averaging over the current history of
            # previous predictions
            results = np.array(Q).mean(axis=0)
            i = (preds > 0.50)[0]
            label = i

            text_color = (0, 255, 0) # default : green

            if label: # Violence prob
                # text_color = (0, 0, 255) # red
                trueCount = trueCount + 1 # added by dhai

            # else:
            #     text_color = (0, 255, 0)

            text = "Violation: {}".format(label)
            FONT = cv2.FONT_HERSHEY_SIMPLEX 

            cv2.putText(output, text, (35, 50), FONT,1.25, text_color, 3) 

            # check if the video writer is None
            # if writer is None:
                # initialize our video writer
            #     fourcc = cv2.VideoWriter_fourcc(*"mp4v")
            #     # vid = "UID" + str(4) + ".mp4"
            #     # cloudfilename = 'Test/' + vid
            #     # storage.child(cloudfilename).put(vid)
            #     writer = cv2.VideoWriter("v_output.mp4", fourcc, 30,(W, H), True)

            # # write the output frame to disk
            # writer.write(output)

            # # show the output image
            # cv2_imshow(output)
            # to get the count and if it is violation video it must be saved in the cloud storage
            # if(trueCount == 50):
            #   print('VIOLATION DETECTED')
            

            # if(imageSaved == 0):
            #   if(label):
            #     # cv2.imwrite(filename, output)
            #     imageSaved = 1 
            #     print("image save 1")  
            # # to delete it to the cloud storage
            # if(imageSaved == 0):
            #   storage.delete(video.name)
            #   print("video.name",video.name)
            #   print("deleted")  


                
                       
            # key = cv2.waitKey(1) & 0xFF

            # # if the `q` key was pressed, break from the loop
            # if key == ord("q"):
            #     break
        # release the file pointersq
        print("[INFO] cleaning up...")
        if(trueCount < -1): # change the thrshold 
          storage.delete(filename) # delete the video ( if it is not violation )
          print("deleted")
        else:
          blob = storage.bucket.blob(filename) 
          new_name =os.path.split(filename)[0]+"/"+"1_" +os.path.split(filename)[1] # change the name from filename ----> 1_filename (to indicate it is violation)
          print(new_name)
          storage.bucket.rename_blob(blob, new_name=os.path.split(filename)[0]+"/"+"1_" +os.path.split(filename)[1]) # rename the file 
          #rename bucket
          drivers = db.collection("drivers")

          # add pending report
          # add an empty document
          filefile = os.path.split(filename)[0]
          # print("filefile",filefile.split("\\"))
          print(type(filefile))
          print(filefile)

          doc_ref = drivers.document(filename.split("/")[0]).collection('reports').document() # filename.split("/")[0] --> driver doc id 
          #set all the fields of the pending report
          print(doc_ref)
          addReport = doc_ref.set({
              'addInfo': 'null',
              'id': doc_ref.id,
              'status': 0,
              'v_type': 'null'

          })
          # add the video to the report (sub collection)
          VideoDoc = drivers.document(filename.split("/")[0]).collection('reports').document(doc_ref.id).collection('video').document() # doc_ref.id --> report id 

          addVideo = VideoDoc.set({
              'id': VideoDoc.id,
              'video_url': storage.child(new_name).get_url(None)
          } )


          #
          #
          
          print("rename")

        # writer.release()
        # vs.release()

import re
all_files = storage.list_files()

for file in all_files:
    if (os.path.split(file.name)[1] != ''):
      str = os.path.split(file.name)[1]
      print(os.path.split(file.name)[0])
      match = re.search(r'\d+', str)
      if match:
        print('First number found:', match.group())
        if(match.group() == '1'):
          print("not allowed")
          print(os.path.split(file.name)[1])
        else:
          print(file.name)
          print_results(storage.child(file.name).get_url(None), file.name) # calling the model (the video not proccessed eat)
      else:
        print(file.name)
        print_results(storage.child(file.name).get_url(None), file.name) # # calling the model (the video not proccessed eat)



      # print(str[:1])
      # print(file.name)
      # print_results(storage.child(file.name).get_url(None), file.name)

#     print("File name: " + file.name +  " Link: " + storage.child(file.name).get_url(None))
#     print(os.path.split(file.name)[1])
# print("File name: " + file.name +  " Link: " + storage.child(file.name).get_url(None))
