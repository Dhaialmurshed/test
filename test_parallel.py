# -*- coding: utf-8 -*-
"""test_parallel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V9NZ8g1k28P0AD5VkDblNEG466lfhkN_
"""


import firebase_admin
from firebase_admin import credentials, storage, firestore # database
import pyrebase # for the storage
from keras.models import load_model
from collections import deque
from timebudget import timebudget
from multiprocessing import Pool
from datetime import datetime
import pytz
import matplotlib.pyplot as plt
import numpy as np
import argparse
import pickle
import cv2
import os
import time 
import re


#setUpÂ 
cred = credentials.Certificate("rasd-d3906-firebase-adminsdk-1djor-5a3d387306.json")
firebase_admin.initialize_app(cred , {'storageBucket':'rasd-d3906.appspot.com'}) # run once ( database config )


firebaseConfig={
      "apiKey": "AIzaSyAN6rb8AKV_qMYknz38SVBZPcp3DGYWzzs",
      "authDomain": "rasd-d3906.firebaseapp.com",
      "databaseURL": "https://rasd-d3906.firebaseio.com",
      "projectId": "rasd-d3906",
      "storageBucket": "rasd-d3906.appspot.com",
      "messagingSenderId": "631946154635",
      "appId": "1:631946154635:android:57200f3f24d236d430fa8e",
      'serviceAccount': 'rasd-d3906-firebase-adminsdk-1djor-5a3d387306.json'
      }
# firebase = pyrebase.initialize_app(firebaseConfig) # for storage configure 
# storage = firebase.storage() #storage

db1=firestore.client()
result = db1.collection('drivers').get() #get the number of users
numUsers = len(result)
# print("numUsers", numUsers)

#git the users ids
users = []
for i in range(numUsers):
  users.append(result[i].to_dict()['id'])

print(users)

def predictViolation():
#   print('--------------in predictViolation', uid)
  firebase = pyrebase.initialize_app(firebaseConfig) # for storage configure 
  storage = firebase.storage() #storage
  print("in predict")

  db=firestore.client()
  def print_results(video, filename, limit=None):
          trueCount = 0

          #print("video.name",filename)
          #print("video",video)

          print("Loading model ...")
          
          model = load_model('driftingModel.h5')
          Q = deque(maxlen=128)
          vs = cv2.VideoCapture(video)
          writer = None
          (W, H) = (None, None)
          count = 0
          frameCounter = 0
        

          while True:
              # read the next frame from the file
              (grabbed, frame) = vs.read()
              frameCounter += 1
             # print("frameCounter",frameCounter)
              if frameCounter == 30:
               # print("last frame per seond")
              # if the frame was not grabbed, then we have reached the end of the stream
                if not grabbed:
                    break
                
                # if the frame dimensions are empty, grab them
                if W is None or H is None:
                    (H, W) = frame.shape[:2]

                # clone the output frame, then convert it from BGR to RGB
                # ordering, resize the frame to a fixed 128x128, and then
                # perform mean subtraction
                
                output = frame.copy()
              
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame = cv2.resize(frame, (128, 128)).astype("float32")
                frame = frame.reshape(128, 128, 3) / 255

                # make predictions on the frame and then update the predictions queue
                preds = model.predict(np.expand_dims(frame, axis=0))[0]
                #print("preds",preds)
                Q.append(preds)

                # perform prediction averaging over the current history of previous predictions
                results = np.array(Q).mean(axis=0)
                i = (preds > 0.50)[0]
                label = i

                text_color = (0, 255, 0) # default : green

                if label: # Violence prob
                    # text_color = (0, 0, 255) # red
                    trueCount = trueCount + 1 # added by dhai

                # else:
                #     text_color = (0, 255, 0)

                text = "Violation: {}".format(label)
                FONT = cv2.FONT_HERSHEY_SIMPLEX 

                cv2.putText(output, text, (35, 50), FONT,1.25, text_color, 3)
                frameCounter = 0
              
          # release the file pointersq
#           print("[INFO] cleaning up...")
          if(trueCount < -1): # change the thrshold 
            storage.delete(filename, token = any) # delete the video ( if it is not violation )
#             print("deleted")
          else:
            blob = storage.bucket.blob(filename) 
            new_name =os.path.split(filename)[0]+"/"+"1_" +os.path.split(filename)[1] # change the name from filename ----> 1_filename (to indicate it is violation)
            #print(new_name)
            storage.bucket.rename_blob(blob, new_name=os.path.split(filename)[0]+"/"+"1_" +os.path.split(filename)[1]) # rename the file 
            #rename bucket
            datetime_ist = datetime.now(pytz.timezone('Asia/Riyadh'))
            drivers = db.collection("drivers")

            # add pending report
            # add an empty document
            doc_ref = drivers.document(filename.split("/")[0]).collection('reports').document() # filename.split("/")[0] --> driver doc id 
            #set all the fields of the pending report
            print(doc_ref)
            addReport = doc_ref.set({
                'addInfo': 'null',
                'id': doc_ref.id,
                'status': 0,
                'v_type': 'null',
                'date': datetime_ist.strftime('%Y:%m:%d'),
                'time': datetime_ist.strftime('%H:%M:%S '),

            })
            # add the video to the report (sub collection)
            VideoDoc = drivers.document(filename.split("/")[0]).collection('reports').document(doc_ref.id).collection('video').document() # doc_ref.id --> report id 

            addVideo = VideoDoc.set({
                'id': VideoDoc.id,
                'video_url': storage.child(new_name).get_url(None)
            } )


            #print("rename")

  all_files = storage.list_files()

  for file in all_files:
#       if(file.name.split("/")[0] == uid): #only process videos of the sent user ID
      if (os.path.split(file.name)[1] != ''): #only procces video files 
        str = os.path.split(file.name)[1] #get the video file name
          #print(os.path.split(file.name)[0])
#         match = re.search(r'\d+', str) #search for the any number in the file name
        match = str[0]
        
            #print('First number found:', match.group()) #get the first number
#             if(match.group() == '1'): #if already predicted skip it
        if(match == '1'):
          print("not allowed")
              #print(os.path.split(file.name)[1])
        else:   
            #if the first number is not 1 (not predicted yet)
            #print(file.name)
            print_results(storage.child(file.name).get_url(None), file.name) # calling the model (the video not proccessed eat)
#       else:
#         #if no number found
#         #print(file.name)
#         print_results(storage.child(file.name).get_url(None), file.name) # # calling the model (the video not proccessed eat)

#this is the function that will be run for all users
# def complex_operation(input_index):
# #     time.sleep(25)
# #     print("after sleep")
# #     print('--------------in complex_operation',input_index)
#     predictViolation(input_index)

# #this is the function that will run the code in parallel
# @timebudget
# def run_complex_operations(operation, input, pool):
#     pool.map(operation, input)
# #     pool.terminate()

processes_count = numUsers #the number of times the code will make instances

if __name__ == '__main__':
    predictViolation()
      
#     os.environ['GRPC_POLL_STRATEGY']='poll'
#     processes_pool = Pool(processes_count)
#     run_complex_operations(complex_operation,users, processes_pool)
